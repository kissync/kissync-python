import datetime
import history
import os
import threading

import common

from errors import DownloadException
from errors import FileNameException
from worker import Worker


class Downloader(Worker):
    def __init__(self, api, syncDir):
        self.api = api
        self.syncDir = syncDir
        self._timeoffset = common.calculate_time_offset()

    def _process_task(self, task):
        serverPath = task.path
        path = common.basePath(task.path)
        absolutePath = os.path.join(self.syncDir, path)

        common.createLocalDirs(os.path.dirname(os.path.realpath(absolutePath)))

        if task.isDir is False:
            try:
                with open(absolutePath, 'wb') as f:
                    r = self.api.get('/path/data/', serverPath)
                    for chunk in r.iter_content(chunk_size=1024):
                        if not self.cancelled and chunk:
                            f.write(chunk)
                            f.flush()
                if self.cancelled:
                    self.cancelled = False
            except IOError as err:
                if err.errno == 22:
                    # Depending on the OS, there may be filename restrictions
                    raise FileNameException(err)
                else:
                    raise DownloadException(err)
            except Exception as err:
                raise DownloadException(err)

            if hasattr(task, 'checksum'):
                self._setAttributes(item)
            if syncObject.checksum is None:
                self._setAttributes(syncObject)

    def _setAttributes(self, syncObject):
        if not self.cancelled:
            path = os.path.join(self.syncDir, syncObject.system_path)
            syncObject.checksum = common.getFileHash(path)
            modified = datetime.datetime.fromtimestamp(os.path.getmtime(path)).replace(microsecond=0) - self._timeoffset

            checksumString = "checksum=%s" % syncObject.checksum
            modifiedString = "modified=%s" % modified

            requestAttr = [checksumString, modifiedString]

            apiPath = "/path/info%s" % syncObject.path
            self.api.post(apiPath, attributes=requestAttr)

    def _cancel(self):
        self.cancelled = True


class DownloadThread(threading.Thread):
    def __init__(self, queue, api, syncDir):
        threading.Thread.__init__(self)
        self.downloader = Downloader(api, syncDir)
        self.queue = queue
        self._current_task = None

    def run(self):
        while True:
            self._current_task = self.queue.get()
            try:
                self.downloader.processTask(self._current_task)
            except:
                # Put the syncObject back into the queue and try later
                self.queue.put(self._current_task)
            self.queue.task_done()

    def cancel(self):
        self._cancel()
        self.queue.task_done()

    @property
    def current_task(self):
        return self._current_task
